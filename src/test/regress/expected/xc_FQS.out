-- This file contains tests for Fast Query Shipping (FQS) for queries involving
-- a single table
-- A function to create table on specified nodes 
create or replace function cr_table(tab_schema varchar, nodenums int[], distribution varchar) returns void language plpgsql as $$
declare
	cr_command	varchar;
	nodes		varchar[];
	nodename	varchar;
	nodenames_query varchar;
	nodenames 	varchar;
	node 		int;
	sep			varchar;
	tmp_node	int;
	num_nodes	int;
begin
	nodenames_query := 'SELECT node_name FROM pgxc_node WHERE node_type = ''D'''; 
	cr_command := 'CREATE TABLE ' || tab_schema || ' DISTRIBUTE BY ' || distribution || ' TO NODE ';
	for nodename in execute nodenames_query loop
		nodes := array_append(nodes, nodename);
	end loop;
	nodenames := '';
	sep := '';
	num_nodes := array_length(nodes, 1);
	foreach node in array nodenums loop
		tmp_node := node;
		if (tmp_node < 1 or tmp_node > num_nodes) then
			tmp_node := tmp_node % num_nodes;
			if (tmp_node < 1) then
				tmp_node := num_nodes; 
			end if;
		end if;
		nodenames := nodenames || sep || nodes[tmp_node];
		sep := ', ';
	end loop;
	cr_command := cr_command || nodenames;
	execute cr_command;
end;
$$;
-- Testset 1 for distributed table (by round robin)
select cr_table('tab1_rr(val int, val2 int)', '{1, 2, 3}'::int[], 'round robin');
 cr_table 
----------
 
(1 row)

insert into tab1_rr values (1, 2);
insert into tab1_rr values (2, 4);
insert into tab1_rr values (5, 3);
insert into tab1_rr values (7, 8);
insert into tab1_rr values (9, 2);
-- simple select
-- should get FQSed
select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_rr where val2 = 4;
 val | ?column? |           case            
-----+----------+---------------------------
   2 |        6 | val and val2 are not same
(1 row)

explain (verbose on, nodes off) select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_rr where val2 = 4;
                                                                                    QUERY PLAN                                                                                    
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"  (cost=0.00..0.00 rows=0 width=0)
   Output: tab1_rr.val, (tab1_rr.val2 + 2), CASE tab1_rr.val WHEN tab1_rr.val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END
   Remote query: SELECT val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END AS "case" FROM tab1_rr WHERE (val2 = 4)
(3 rows)

-- should not get FQSed because of aggregates
select sum(val), avg(val), count(*) from tab1_rr;
 sum |        avg         | count 
-----+--------------------+-------
  24 | 4.8000000000000000 |     5
(1 row)

explain (verbose on, nodes off) select sum(val), avg(val), count(*) from tab1_rr;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=8.51..8.52 rows=1 width=4)
   Output: pg_catalog.sum((sum(tab1_rr.val))), pg_catalog.avg((avg(tab1_rr.val))), pg_catalog.count(*)
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (sum(tab1_rr.val)), (avg(tab1_rr.val)), (count(*))
         ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"  (cost=0.00..1.01 rows=1000 width=4)
               Output: sum(tab1_rr.val), avg(tab1_rr.val), count(*)
               Remote query: SELECT sum(group_1.val), avg(group_1.val), count(*)  FROM (SELECT val, val2 FROM ONLY tab1_rr WHERE true) group_1   
(7 rows)

-- should not get FQSed because of window functions
select first_value(val) over (partition by val2 order by val) from tab1_rr;
 first_value 
-------------
           1
           1
           5
           2
           7
(5 rows)

explain (verbose on, nodes off) select first_value(val) over (partition by val2 order by val) from tab1_rr;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 WindowAgg  (cost=50.84..70.84 rows=1000 width=8)
   Output: first_value(val) OVER (?), val, val2
   ->  Sort  (cost=50.84..53.34 rows=1000 width=8)
         Output: val, val2
         Sort Key: tab1_rr.val2, tab1_rr.val
         ->  Result  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
               ->  Data Node Scan on tab1_rr  (cost=0.00..1.01 rows=1000 width=8)
                     Output: val, val2
                     Remote query: SELECT val, val2 FROM ONLY tab1_rr WHERE true
(10 rows)

-- should not get FQSed because of LIMIT clause
select * from tab1_rr where val2 = 3 limit 1;
 val | val2 
-----+------
   5 |    3
(1 row)

explain (verbose on, nodes off) select * from tab1_rr where val2 = 3 limit 1;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Limit  (cost=0.00..0.00 rows=1 width=8)
   Output: val, val2
   ->  Result  (cost=0.00..1.01 rows=1000 width=8)
         Output: val, val2
         ->  Data Node Scan on tab1_rr  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
               Remote query: SELECT val, val2 FROM ONLY tab1_rr WHERE (val2 = 3)
(7 rows)

-- should not FQSed because of OFFSET clause
select * from tab1_rr where val2 = 4 offset 1;
 val | val2 
-----+------
(0 rows)

explain (verbose on, nodes off) select * from tab1_rr where val2 = 4 offset 1;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Limit  (cost=0.00..1.01 rows=999 width=8)
   Output: val, val2
   ->  Result  (cost=0.00..1.01 rows=1000 width=8)
         Output: val, val2
         ->  Data Node Scan on tab1_rr  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
               Remote query: SELECT val, val2 FROM ONLY tab1_rr WHERE (val2 = 4)
(7 rows)

-- should not get FQSed because of SORT clause
select * from tab1_rr order by val;
 val | val2 
-----+------
   1 |    2
   2 |    4
   5 |    3
   7 |    8
   9 |    2
(5 rows)

explain (verbose on, nodes off) select * from tab1_rr order by val;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=50.84..53.34 rows=1000 width=8)
   Output: val, val2
   Sort Key: tab1_rr.val
   ->  Result  (cost=0.00..1.01 rows=1000 width=8)
         Output: val, val2
         ->  Data Node Scan on tab1_rr  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
               Remote query: SELECT val, val2 FROM ONLY tab1_rr WHERE true
(8 rows)

-- should not get FQSed because of DISTINCT clause
select distinct val, val2 from tab1_rr where val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off) select distinct val, val2 from tab1_rr where val2 = 8;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 HashAggregate  (cost=6.01..6.02 rows=1 width=8)
   Output: val, val2
   ->  Result  (cost=0.00..1.01 rows=1000 width=8)
         Output: val, val2
         ->  Data Node Scan on tab1_rr  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
               Remote query: SELECT val, val2 FROM ONLY tab1_rr WHERE (val2 = 8)
(7 rows)

-- should not get FQSed because of GROUP clause
select val, val2 from tab1_rr where val2 = 8 group by val, val2;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off) select val, val2 from tab1_rr where val2 = 8 group by val, val2;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=6.01..6.02 rows=1 width=8)
   Output: tab1_rr.val, tab1_rr.val2
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: tab1_rr.val, tab1_rr.val2
         ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"  (cost=0.00..1.01 rows=1000 width=8)
               Output: tab1_rr.val, tab1_rr.val2
               Remote query: SELECT group_1.val, group_1.val2  FROM (SELECT val, val2 FROM ONLY tab1_rr WHERE (val2 = 8)) group_1 GROUP BY 1, 2  
(7 rows)

-- should not get FQSed because of HAVING clause
select sum(val) from tab1_rr where val2 = 2 group by val2 having sum(val) > 1;
 sum 
-----
  10
(1 row)

explain (verbose on, nodes off) select sum(val) from tab1_rr where val2 = 2 group by val2 having sum(val) > 1;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.00..8.52 rows=1 width=8)
   Output: pg_catalog.sum((sum(tab1_rr.val))), tab1_rr.val2
   Filter: (pg_catalog.sum((sum(tab1_rr.val))) > 1)
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (sum(tab1_rr.val)), tab1_rr.val2
         ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"  (cost=0.00..1.01 rows=1000 width=8)
               Output: sum(tab1_rr.val), tab1_rr.val2
               Remote query: SELECT sum(group_1.val), group_1.val2  FROM (SELECT val, val2 FROM ONLY tab1_rr WHERE (val2 = 2)) group_1 GROUP BY 2  
(8 rows)

-- Testset 2 for distributed tables (by hash)
select cr_table('tab1_hash(val int, val2 int)', '{1, 2, 3}'::int[], 'hash(val)');
 cr_table 
----------
 
(1 row)

insert into tab1_hash values (1, 2);
insert into tab1_hash values (2, 4);
insert into tab1_hash values (5, 3);
insert into tab1_hash values (7, 8);
insert into tab1_hash values (9, 2);
-- simple select
-- should get FQSed
select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_hash where val2 = 4;
 val | ?column? |           case            
-----+----------+---------------------------
   2 |        6 | val and val2 are not same
(1 row)

explain (verbose on, nodes off) select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_hash where val2 = 2;
                                                                                     QUERY PLAN                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"  (cost=0.00..0.00 rows=0 width=0)
   Output: tab1_hash.val, (tab1_hash.val2 + 2), CASE tab1_hash.val WHEN tab1_hash.val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END
   Remote query: SELECT val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END AS "case" FROM tab1_hash WHERE (val2 = 2)
(3 rows)

-- should not get FQSed because of aggregates
select sum(val), avg(val), count(*) from tab1_hash;
 sum |        avg         | count 
-----+--------------------+-------
  24 | 4.8000000000000000 |     5
(1 row)

explain (verbose on, nodes off) select sum(val), avg(val), count(*) from tab1_hash;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=8.51..8.52 rows=1 width=4)
   Output: pg_catalog.sum((sum(tab1_hash.val))), pg_catalog.avg((avg(tab1_hash.val))), pg_catalog.count(*)
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (sum(tab1_hash.val)), (avg(tab1_hash.val)), (count(*))
         ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"  (cost=0.00..1.01 rows=1000 width=4)
               Output: sum(tab1_hash.val), avg(tab1_hash.val), count(*)
               Remote query: SELECT sum(group_1.val), avg(group_1.val), count(*)  FROM (SELECT val, val2 FROM ONLY tab1_hash WHERE true) group_1   
(7 rows)

-- should not get FQSed because of window functions
select first_value(val) over (partition by val2 order by val) from tab1_hash;
 first_value 
-------------
           1
           1
           5
           2
           7
(5 rows)

explain (verbose on, nodes off) select first_value(val) over (partition by val2 order by val) from tab1_hash;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 WindowAgg  (cost=50.84..70.84 rows=1000 width=8)
   Output: first_value(val) OVER (?), val, val2
   ->  Sort  (cost=50.84..53.34 rows=1000 width=8)
         Output: val, val2
         Sort Key: tab1_hash.val2, tab1_hash.val
         ->  Result  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
               ->  Data Node Scan on tab1_hash  (cost=0.00..1.01 rows=1000 width=8)
                     Output: val, val2
                     Remote query: SELECT val, val2 FROM ONLY tab1_hash WHERE true
(10 rows)

-- should not get FQSed because of LIMIT clause
select * from tab1_hash where val2 = 3 limit 1;
 val | val2 
-----+------
   5 |    3
(1 row)

explain (verbose on, nodes off) select * from tab1_hash where val2 = 3 limit 1;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Limit  (cost=0.00..0.00 rows=1 width=8)
   Output: val, val2
   ->  Result  (cost=0.00..1.01 rows=1000 width=8)
         Output: val, val2
         ->  Data Node Scan on tab1_hash  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
               Remote query: SELECT val, val2 FROM ONLY tab1_hash WHERE (val2 = 3)
(7 rows)

-- should not FQSed because of OFFSET clause
select * from tab1_hash where val2 = 4 offset 1;
 val | val2 
-----+------
(0 rows)

explain (verbose on, nodes off) select * from tab1_hash where val2 = 4 offset 1;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Limit  (cost=0.00..1.01 rows=999 width=8)
   Output: val, val2
   ->  Result  (cost=0.00..1.01 rows=1000 width=8)
         Output: val, val2
         ->  Data Node Scan on tab1_hash  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
               Remote query: SELECT val, val2 FROM ONLY tab1_hash WHERE (val2 = 4)
(7 rows)

-- should not get FQSed because of SORT clause
select * from tab1_hash order by val;
 val | val2 
-----+------
   1 |    2
   2 |    4
   5 |    3
   7 |    8
   9 |    2
(5 rows)

explain (verbose on, nodes off) select * from tab1_hash order by val;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Sort  (cost=50.84..53.34 rows=1000 width=8)
   Output: val, val2
   Sort Key: tab1_hash.val
   ->  Result  (cost=0.00..1.01 rows=1000 width=8)
         Output: val, val2
         ->  Data Node Scan on tab1_hash  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
               Remote query: SELECT val, val2 FROM ONLY tab1_hash WHERE true
(8 rows)

-- should not get FQSed because of DISTINCT clause
select distinct val, val2 from tab1_hash where val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off) select distinct val, val2 from tab1_hash where val2 = 8;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 HashAggregate  (cost=6.01..6.02 rows=1 width=8)
   Output: val, val2
   ->  Result  (cost=0.00..1.01 rows=1000 width=8)
         Output: val, val2
         ->  Data Node Scan on tab1_hash  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
               Remote query: SELECT val, val2 FROM ONLY tab1_hash WHERE (val2 = 8)
(7 rows)

-- should not get FQSed because of GROUP clause
select val, val2 from tab1_hash where val2 = 8 group by val, val2;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off) select val, val2 from tab1_hash where val2 = 8 group by val, val2;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=6.01..6.02 rows=1 width=8)
   Output: tab1_hash.val, tab1_hash.val2
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: tab1_hash.val, tab1_hash.val2
         ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"  (cost=0.00..1.01 rows=1000 width=8)
               Output: tab1_hash.val, tab1_hash.val2
               Remote query: SELECT group_1.val, group_1.val2  FROM (SELECT val, val2 FROM ONLY tab1_hash WHERE (val2 = 8)) group_1 GROUP BY 1, 2  
(7 rows)

-- should not get FQSed because of HAVING clause
select sum(val) from tab1_hash where val2 = 2 group by val2 having sum(val) > 1;
 sum 
-----
  10
(1 row)

explain (verbose on, nodes off) select sum(val) from tab1_hash where val2 = 2 group by val2 having sum(val) > 1;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.00..8.52 rows=1 width=8)
   Output: pg_catalog.sum((sum(tab1_hash.val))), tab1_hash.val2
   Filter: (pg_catalog.sum((sum(tab1_hash.val))) > 1)
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (sum(tab1_hash.val)), tab1_hash.val2
         ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"  (cost=0.00..1.01 rows=1000 width=8)
               Output: sum(tab1_hash.val), tab1_hash.val2
               Remote query: SELECT sum(group_1.val), group_1.val2  FROM (SELECT val, val2 FROM ONLY tab1_hash WHERE (val2 = 2)) group_1 GROUP BY 2  
(8 rows)

-- Testset 3 for distributed tables (by modulo)
select cr_table('tab1_modulo(val int, val2 int)', '{1, 2, 3}'::int[], 'modulo(val)');
 cr_table 
----------
 
(1 row)

insert into tab1_modulo values (1, 2);
insert into tab1_modulo values (2, 4);
insert into tab1_modulo values (5, 3);
insert into tab1_modulo values (7, 8);
insert into tab1_modulo values (9, 2);
-- simple select
-- should get FQSed
select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_modulo where val2 = 4;
 val | ?column? |           case            
-----+----------+---------------------------
   2 |        6 | val and val2 are not same
(1 row)

explain (verbose on, nodes off) select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_modulo where val2 = 4;
                                                                                      QUERY PLAN                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"  (cost=0.00..0.00 rows=0 width=0)
   Output: tab1_modulo.val, (tab1_modulo.val2 + 2), CASE tab1_modulo.val WHEN tab1_modulo.val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END
   Remote query: SELECT val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END AS "case" FROM tab1_modulo WHERE (val2 = 4)
(3 rows)

-- should not get FQSed because of aggregates
select sum(val), avg(val), count(*) from tab1_modulo;
 sum |        avg         | count 
-----+--------------------+-------
  24 | 4.8000000000000000 |     5
(1 row)

explain (verbose on, nodes off) select sum(val), avg(val), count(*) from tab1_modulo;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=8.51..8.52 rows=1 width=4)
   Output: pg_catalog.sum((sum(tab1_modulo.val))), pg_catalog.avg((avg(tab1_modulo.val))), pg_catalog.count(*)
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (sum(tab1_modulo.val)), (avg(tab1_modulo.val)), (count(*))
         ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"  (cost=0.00..1.01 rows=1000 width=4)
               Output: sum(tab1_modulo.val), avg(tab1_modulo.val), count(*)
               Remote query: SELECT sum(group_1.val), avg(group_1.val), count(*)  FROM (SELECT val, val2 FROM ONLY tab1_modulo WHERE true) group_1   
(7 rows)

-- should not get FQSed because of window functions
select first_value(val) over (partition by val2 order by val) from tab1_modulo;
 first_value 
-------------
           1
           1
           5
           2
           7
(5 rows)

explain (verbose on, nodes off) select first_value(val) over (partition by val2 order by val) from tab1_modulo;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 WindowAgg  (cost=50.84..70.84 rows=1000 width=8)
   Output: first_value(val) OVER (?), val, val2
   ->  Sort  (cost=50.84..53.34 rows=1000 width=8)
         Output: val, val2
         Sort Key: tab1_modulo.val2, tab1_modulo.val
         ->  Result  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
               ->  Data Node Scan on tab1_modulo  (cost=0.00..1.01 rows=1000 width=8)
                     Output: val, val2
                     Remote query: SELECT val, val2 FROM ONLY tab1_modulo WHERE true
(10 rows)

-- should not get FQSed because of LIMIT clause
select * from tab1_modulo where val2 = 3 limit 1;
 val | val2 
-----+------
   5 |    3
(1 row)

explain (verbose on, nodes off) select * from tab1_modulo where val2 = 3 limit 1;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Limit  (cost=0.00..0.00 rows=1 width=8)
   Output: val, val2
   ->  Result  (cost=0.00..1.01 rows=1000 width=8)
         Output: val, val2
         ->  Data Node Scan on tab1_modulo  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
               Remote query: SELECT val, val2 FROM ONLY tab1_modulo WHERE (val2 = 3)
(7 rows)

-- should not FQSed because of OFFSET clause
select * from tab1_modulo where val2 = 4 offset 1;
 val | val2 
-----+------
(0 rows)

explain (verbose on, nodes off) select * from tab1_modulo where val2 = 4 offset 1;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Limit  (cost=0.00..1.01 rows=999 width=8)
   Output: val, val2
   ->  Result  (cost=0.00..1.01 rows=1000 width=8)
         Output: val, val2
         ->  Data Node Scan on tab1_modulo  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
               Remote query: SELECT val, val2 FROM ONLY tab1_modulo WHERE (val2 = 4)
(7 rows)

-- should not get FQSed because of SORT clause
select * from tab1_modulo order by val;
 val | val2 
-----+------
   1 |    2
   2 |    4
   5 |    3
   7 |    8
   9 |    2
(5 rows)

explain (verbose on, nodes off) select * from tab1_modulo order by val;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=50.84..53.34 rows=1000 width=8)
   Output: val, val2
   Sort Key: tab1_modulo.val
   ->  Result  (cost=0.00..1.01 rows=1000 width=8)
         Output: val, val2
         ->  Data Node Scan on tab1_modulo  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
               Remote query: SELECT val, val2 FROM ONLY tab1_modulo WHERE true
(8 rows)

-- should not get FQSed because of DISTINCT clause
select distinct val, val2 from tab1_modulo where val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off) select distinct val, val2 from tab1_modulo where val2 = 8;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 HashAggregate  (cost=6.01..6.02 rows=1 width=8)
   Output: val, val2
   ->  Result  (cost=0.00..1.01 rows=1000 width=8)
         Output: val, val2
         ->  Data Node Scan on tab1_modulo  (cost=0.00..1.01 rows=1000 width=8)
               Output: val, val2
               Remote query: SELECT val, val2 FROM ONLY tab1_modulo WHERE (val2 = 8)
(7 rows)

-- should not get FQSed because of GROUP clause
select val, val2 from tab1_modulo where val2 = 8 group by val, val2;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (verbose on, nodes off) select val, val2 from tab1_modulo where val2 = 8 group by val, val2;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=6.01..6.02 rows=1 width=8)
   Output: tab1_modulo.val, tab1_modulo.val2
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: tab1_modulo.val, tab1_modulo.val2
         ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"  (cost=0.00..1.01 rows=1000 width=8)
               Output: tab1_modulo.val, tab1_modulo.val2
               Remote query: SELECT group_1.val, group_1.val2  FROM (SELECT val, val2 FROM ONLY tab1_modulo WHERE (val2 = 8)) group_1 GROUP BY 1, 2  
(7 rows)

-- should not get FQSed because of HAVING clause
select sum(val) from tab1_modulo where val2 = 2 group by val2 having sum(val) > 1;
 sum 
-----
  10
(1 row)

explain (verbose on, nodes off) select sum(val) from tab1_modulo where val2 = 2 group by val2 having sum(val) > 1;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.00..8.52 rows=1 width=8)
   Output: pg_catalog.sum((sum(tab1_modulo.val))), tab1_modulo.val2
   Filter: (pg_catalog.sum((sum(tab1_modulo.val))) > 1)
   ->  Materialize  (cost=0.00..0.00 rows=0 width=0)
         Output: (sum(tab1_modulo.val)), tab1_modulo.val2
         ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"  (cost=0.00..1.01 rows=1000 width=8)
               Output: sum(tab1_modulo.val), tab1_modulo.val2
               Remote query: SELECT sum(group_1.val), group_1.val2  FROM (SELECT val, val2 FROM ONLY tab1_modulo WHERE (val2 = 2)) group_1 GROUP BY 2  
(8 rows)

-- Testset 4 for replicated tables, for replicated tables, unless the expression
-- is itself unshippable, any query involving a single replicated table is shippable
select cr_table('tab1_replicated(val int, val2 int)', '{1, 2, 3}'::int[], 'replication');
 cr_table 
----------
 
(1 row)

insert into tab1_replicated values (1, 2);
insert into tab1_replicated values (2, 4);
insert into tab1_replicated values (5, 3);
insert into tab1_replicated values (7, 8);
insert into tab1_replicated values (9, 2);
-- simple select
select * from tab1_replicated;
 val | val2 
-----+------
   1 |    2
   2 |    4
   5 |    3
   7 |    8
   9 |    2
(5 rows)

explain (num_nodes on, verbose on, nodes off) select * from tab1_replicated;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"  (cost=0.00..0.00 rows=0 width=0)
   Output: tab1_replicated.val, tab1_replicated.val2
   Remote query: SELECT val, val2 FROM tab1_replicated
(3 rows)

select sum(val), avg(val), count(*) from tab1_replicated;
 sum |        avg         | count 
-----+--------------------+-------
  24 | 4.8000000000000000 |     5
(1 row)

explain (num_nodes on, verbose on, nodes off) select sum(val), avg(val), count(*) from tab1_replicated;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"  (cost=0.00..0.00 rows=0 width=0)
   Output: sum(tab1_replicated.val), avg(tab1_replicated.val), count(*)
   Remote query: SELECT sum(val) AS sum, pg_catalog.int8_avg(avg(val)) AS avg, count(*) AS count FROM tab1_replicated
(3 rows)

select first_value(val) over (partition by val2 order by val) from tab1_replicated;
 first_value 
-------------
           1
           1
           5
           2
           7
(5 rows)

explain (num_nodes on, verbose on, nodes off) select first_value(val) over (partition by val2 order by val) from tab1_replicated;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"  (cost=0.00..0.00 rows=0 width=0)
   Output: first_value(tab1_replicated.val) OVER (?), tab1_replicated.val, tab1_replicated.val2
   Remote query: SELECT first_value(val) OVER (PARTITION BY val2 ORDER BY val) AS first_value FROM tab1_replicated
(3 rows)

select * from tab1_replicated where val2 = 2 limit 2;
 val | val2 
-----+------
   1 |    2
   9 |    2
(2 rows)

explain (num_nodes on, verbose on, nodes off) select * from tab1_replicated where val2 = 2 limit 2;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"  (cost=0.00..0.00 rows=0 width=0)
   Output: tab1_replicated.val, tab1_replicated.val2
   Remote query: SELECT val, val2 FROM tab1_replicated WHERE (val2 = 2) LIMIT 2
(3 rows)

select * from tab1_replicated where val2 = 4 offset 1;
 val | val2 
-----+------
(0 rows)

explain (num_nodes on, verbose on, nodes off) select * from tab1_replicated where val2 = 4 offset 1;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"  (cost=0.00..0.00 rows=0 width=0)
   Output: tab1_replicated.val, tab1_replicated.val2
   Remote query: SELECT val, val2 FROM tab1_replicated WHERE (val2 = 4) OFFSET 1
(3 rows)

select * from tab1_replicated order by val;
 val | val2 
-----+------
   1 |    2
   2 |    4
   5 |    3
   7 |    8
   9 |    2
(5 rows)

explain (num_nodes on, verbose on, nodes off) select * from tab1_replicated order by val;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"  (cost=0.00..0.00 rows=0 width=0)
   Output: tab1_replicated.val, tab1_replicated.val2
   Remote query: SELECT val, val2 FROM tab1_replicated ORDER BY val
(3 rows)

select distinct val, val2 from tab1_replicated;
 val | val2 
-----+------
   9 |    2
   5 |    3
   1 |    2
   2 |    4
   7 |    8
(5 rows)

explain (num_nodes on, verbose on, nodes off) select distinct val, val2 from tab1_replicated;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"  (cost=0.00..0.00 rows=0 width=0)
   Output: tab1_replicated.val, tab1_replicated.val2
   Remote query: SELECT DISTINCT val, val2 FROM tab1_replicated
(3 rows)

select val, val2 from tab1_replicated group by val, val2;
 val | val2 
-----+------
   9 |    2
   5 |    3
   1 |    2
   2 |    4
   7 |    8
(5 rows)

explain (num_nodes on, verbose on, nodes off) select val, val2 from tab1_replicated group by val, val2;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"  (cost=0.00..0.00 rows=0 width=0)
   Output: tab1_replicated.val, tab1_replicated.val2
   Remote query: SELECT val, val2 FROM tab1_replicated GROUP BY val, val2
(3 rows)

select sum(val) from tab1_replicated group by val2 having sum(val) > 1;
 sum 
-----
   7
   2
   5
  10
(4 rows)

explain (num_nodes on, verbose on, nodes off) select sum(val) from tab1_replicated group by val2 having sum(val) > 1;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"  (cost=0.00..0.00 rows=0 width=0)
   Output: sum(tab1_replicated.val), tab1_replicated.val2
   Remote query: SELECT sum(val) AS sum FROM tab1_replicated GROUP BY val2 HAVING (sum(val) > 1)
(3 rows)

drop table tab1_rr;
drop table tab1_hash;
drop table tab1_modulo;
drop table tab1_replicated;
drop function cr_table(varchar, int[], varchar); 
