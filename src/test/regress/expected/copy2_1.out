CREATE TEMP TABLE x (
	a serial,
	b int,
	c text not null default 'stuff',
	d text,
	e text
) WITH OIDS;
NOTICE:  CREATE TABLE will create implicit sequence "x_a_seq" for serial column "x.a"
CREATE FUNCTION fn_x_before () RETURNS TRIGGER AS '
  BEGIN
		NEW.e := ''before trigger fired''::text;
		return NEW;
	END;
' LANGUAGE plpgsql;
CREATE FUNCTION fn_x_after () RETURNS TRIGGER AS '
  BEGIN
		UPDATE x set e=''after trigger fired'' where c=''stuff'';
		return NULL;
	END;
' LANGUAGE plpgsql;
CREATE TRIGGER trg_x_after AFTER INSERT ON x
FOR EACH ROW EXECUTE PROCEDURE fn_x_after();
ERROR:  Postgres-XC does not support TRIGGER yet
DETAIL:  The feature is not currently supported
CREATE TRIGGER trg_x_before BEFORE INSERT ON x
FOR EACH ROW EXECUTE PROCEDURE fn_x_before();
ERROR:  Postgres-XC does not support TRIGGER yet
DETAIL:  The feature is not currently supported
COPY x (a, b, c, d, e) from stdin;
COPY x (b, d) from stdin;
COPY x (b, d) from stdin;
COPY x (a, b, c, d, e) from stdin;
-- non-existent column in column list: should fail
COPY x (xyz) from stdin;
ERROR:  column "xyz" of relation "x" does not exist
-- too many columns in column list: should fail
COPY x (a, b, c, d, e, d, c) from stdin;
ERROR:  column "d" specified more than once
-- missing data: should fail
COPY x from stdin;
ERROR:  invalid input syntax for integer: ""
CONTEXT:  COPY x, line 1, column a: ""
COPY x from stdin;
ERROR:  missing data for column "e"
CONTEXT:  COPY x, line 1: "2000	230	23	23"
COPY x from stdin;
ERROR:  missing data for column "e"
CONTEXT:  COPY x, line 1: "2001	231	\N	\N"
-- extra data: should fail
COPY x from stdin;
ERROR:  extra data after last expected column
CONTEXT:  COPY x, line 1: "2002	232	40	50	60	70	80"
-- various COPY options: delimiters, oids, NULL string, encoding
COPY x (b, c, d, e) from stdin with oids delimiter ',' null 'x';
COPY x from stdin WITH DELIMITER AS ';' NULL AS '';
COPY x from stdin WITH DELIMITER AS ':' NULL AS E'\\X' ENCODING 'sql_ascii';
-- check results of copy in
SELECT * FROM x ORDER BY a, b;
   a   | b  |     c      |   d    | e  
-------+----+------------+--------+----
     1 |  1 | stuff      | test_1 | 
     1 |  2 | stuff      | test_2 | 
     1 |  3 | stuff      | test_3 | 
     1 |  4 | stuff      | test_4 | 
     1 |  5 | stuff      | test_5 | 
     1 |    | 45         | 80     | 90
     1 |    | ,          | \,     | \
     1 |    | x          | \x     | \x
  3000 |    | c          |        | 
  4000 |    | C          |        | 
  4001 |  1 | empty      |        | 
  4002 |  2 | null       |        | 
  4003 |  3 | Backslash  | \      | \
  4004 |  4 | BackslashX | \X     | \X
  4005 |  5 | N          | N      | N
  4006 |  6 | BackslashN | \N     | \N
  4007 |  7 | XX         | XX     | XX
  4008 |  8 | Delimiter  | :      | :
  9999 |    | \N         | NN     | 
 10000 | 21 | 31         | 41     | 51
 10001 | 22 | 32         | 42     | 52
 10002 | 23 | 33         | 43     | 53
 10003 | 24 | 34         | 44     | 54
 10004 | 25 | 35         | 45     | 55
 10005 | 26 | 36         | 46     | 56
(25 rows)

-- COPY w/ oids on a table w/o oids should fail
CREATE TABLE no_oids (
	a	int,
	b	int
) WITHOUT OIDS;
INSERT INTO no_oids (a, b) VALUES (5, 10);
INSERT INTO no_oids (a, b) VALUES (20, 30);
-- should fail
COPY no_oids FROM stdin WITH OIDS;
ERROR:  table "no_oids" does not have OIDs
COPY no_oids TO stdout WITH OIDS;
ERROR:  table "no_oids" does not have OIDs
-- check copy out
COPY x TO stdout;
9999	\N	\\N	NN	\N
1	1	stuff	test_1	\N
1	2	stuff	test_2	\N
1	3	stuff	test_3	\N
1	4	stuff	test_4	\N
1	5	stuff	test_5	\N
10001	22	32	42	52
10002	23	33	43	53
10004	25	35	45	55
1	\N	45	80	90
1	\N	x	\\x	\\x
1	\N	,	\\,	\\
4000	\N	C	\N	\N
4002	2	null	\N	\N
4003	3	Backslash	\\	\\
4005	5	N	N	N
4007	7	XX	XX	XX
4008	8	Delimiter	:	:
10000	21	31	41	51
10003	24	34	44	54
10005	26	36	46	56
3000	\N	c	\N	\N
4001	1	empty		
4004	4	BackslashX	\\X	\\X
4006	6	BackslashN	\\N	\\N
COPY x (c, e) TO stdout;
\\N	\N
stuff	\N
stuff	\N
stuff	\N
stuff	\N
stuff	\N
32	52
33	53
35	55
45	90
x	\\x
,	\\
C	\N
null	\N
Backslash	\\
N	N
XX	XX
Delimiter	:
31	51
34	54
36	56
c	\N
empty	
BackslashX	\\X
BackslashN	\\N
COPY x (b, e) TO stdout WITH NULL 'I''m null';
I'm null	I'm null
1	I'm null
2	I'm null
3	I'm null
4	I'm null
5	I'm null
22	52
23	53
25	55
I'm null	90
I'm null	\\x
I'm null	\\
I'm null	I'm null
2	I'm null
3	\\
5	N
7	XX
8	:
21	51
24	54
26	56
I'm null	I'm null
1	
4	\\X
6	\\N
CREATE TEMP TABLE y (
	col1 text,
	col2 text
);
INSERT INTO y VALUES ('Jackson, Sam', E'\\h');
INSERT INTO y VALUES ('It is "perfect".',E'\t');
INSERT INTO y VALUES ('', NULL);
COPY y TO stdout WITH CSV;
"Jackson, Sam",\h
"It is ""perfect"".",	
"",
COPY y TO stdout WITH CSV QUOTE '''' DELIMITER '|';
Jackson, Sam|\h
It is "perfect".|	
''|
COPY y TO stdout WITH CSV FORCE QUOTE col2 ESCAPE E'\\' ENCODING 'sql_ascii';
"Jackson, Sam","\\h"
"It is \"perfect\".","	"
"",
COPY y TO stdout WITH CSV FORCE QUOTE *;
"Jackson, Sam",\h
"It is ""perfect"".",	
"",
-- Repeat above tests with new 9.0 option syntax
COPY y TO stdout (FORMAT CSV);
"Jackson, Sam",\h
"It is ""perfect"".",	
"",
COPY y TO stdout (FORMAT CSV, QUOTE '''', DELIMITER '|');
Jackson, Sam|\h
It is "perfect".|	
''|
COPY y TO stdout (FORMAT CSV, FORCE_QUOTE (col2), ESCAPE E'\\');
"Jackson, Sam","\\h"
"It is \"perfect\".","	"
"",
COPY y TO stdout (FORMAT CSV, FORCE_QUOTE *);
"Jackson, Sam",\h
"It is ""perfect"".",	
"",
\copy y TO stdout (FORMAT CSV)
"Jackson, Sam",\h
"It is ""perfect"".",	
"",
\copy y TO stdout (FORMAT CSV, QUOTE '''', DELIMITER '|')
Jackson, Sam|\h
It is "perfect".|	
''|
\copy y TO stdout (FORMAT CSV, FORCE_QUOTE (col2), ESCAPE E'\\')
"Jackson, Sam","\\h"
"It is \"perfect\".","	"
"",
\copy y TO stdout (FORMAT CSV, FORCE_QUOTE *)
"Jackson, Sam",\h
"It is ""perfect"".",	
"",
--test that we read consecutive LFs properly
CREATE TEMP TABLE testnl (a int, b text, c int);
COPY testnl FROM stdin CSV;
-- test end of copy marker
CREATE TEMP TABLE testeoc (a text);
COPY testeoc FROM stdin CSV;
COPY testeoc TO stdout CSV;
"\."
a\.
\.b
c\.d
DROP TABLE x, y;
DROP FUNCTION fn_x_before();
DROP FUNCTION fn_x_after();
